/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package InternalFrame;

import BackEnd.B_calculation;
import BackEnd.E_Spheres_calculation;
import BackEnd.E_calculation;
import BackEnd.E_old_calculation;
import BackEnd.FazorVektor;
import BackEnd.Observer;
import BackEnd.databaza;
import BackEnd.rozpatie;
import static de.dislin.Dislin.graf3;
import dislin.plot_1D;
import dislin.plot_2D;
import java.util.ArrayList;

import emft_vol2.constants;
import static emft_vol2.constants_Jframe.constants_JframeIsOpen;
import emft_vol2.main_Jframe;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.accessibility.AccessibleContext;
import javax.swing.JOptionPane;
import javax.swing.JTextField;
import javax.swing.event.InternalFrameEvent;
import javax.swing.event.InternalFrameListener;
import org.apache.commons.math.complex.Complex;
import org.jdelaunay.delaunay.error.DelaunayError;
import org.jdelaunay.delaunay.geometries.DPoint;
import tools.help;

/**
 *
 * @author Jozef
 */
public class InternalFrameproject extends javax.swing.JInternalFrame {

    // deklarovanie default values
    static double A = 300;
    static double Z = 20;
    static double krok_poz = 1; //m
    static double krok = 1000; //vmm
    static ArrayList<double[]> body = new ArrayList<double[]>();
    static String meno_rozpatia = language_internal_frame.LangLabel(constants.getLanguage_option(), 0);
    static String meno_projektu = language_internal_frame.LangLabel(constants.getLanguage_option(), 1);
    ;
      public static rozpatie Rozpätie = new rozpatie(meno_rozpatia, meno_projektu, A, Z, krok, krok_poz);

    // databazy
    public databaza BE = new databaza();
    public databaza BEplus = new databaza();
    public boolean BEpluspovolene = false;

    /**
     * Creates new form New
     */
    public InternalFrameproject() {
        initComponents();

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jMenuItem1 = new javax.swing.JMenuItem();
        basicInfoPanel = new InternalFrame.BasicInfoPanel();
        basicSettingsPanel = new InternalFrame.BasicSettingsPanel();
        catenaryPanel1 = new InternalFrame.CatenaryPanel();
        observerPanel1 = new InternalFrame.ObserverPanel();
        jPanel1 = new javax.swing.JPanel();
        calcB = new javax.swing.JButton();
        calcE_OLD = new javax.swing.JButton();
        calcE_OLD_plus = new javax.swing.JButton();
        calcE_square = new javax.swing.JButton();
        outputPanel2 = new InternalFrame.outputPanel();

        jMenuItem1.setText("jMenuItem1");

        setClosable(true);
        setIconifiable(true);
        setMaximizable(true);
        setResizable(true);
        setAutoscrolls(true);
        addInternalFrameListener(new javax.swing.event.InternalFrameListener() {
            public void internalFrameActivated(javax.swing.event.InternalFrameEvent evt) {
            }
            public void internalFrameClosed(javax.swing.event.InternalFrameEvent evt) {
                formInternalFrameClosed(evt);
            }
            public void internalFrameClosing(javax.swing.event.InternalFrameEvent evt) {
            }
            public void internalFrameDeactivated(javax.swing.event.InternalFrameEvent evt) {
            }
            public void internalFrameDeiconified(javax.swing.event.InternalFrameEvent evt) {
            }
            public void internalFrameIconified(javax.swing.event.InternalFrameEvent evt) {
            }
            public void internalFrameOpened(javax.swing.event.InternalFrameEvent evt) {
            }
        });

        jPanel1.setBackground(new java.awt.Color(0, 102, 102));

        calcB.setText("B");
        calcB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                calcBActionPerformed(evt);
            }
        });

        calcE_OLD.setText("Eo");
        calcE_OLD.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                calcE_OLDActionPerformed(evt);
            }
        });

        calcE_OLD_plus.setText("Eo plus");
        calcE_OLD_plus.setEnabled(false);
        calcE_OLD_plus.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                calcE_OLD_plusActionPerformed(evt);
            }
        });

        calcE_square.setText("E sphere");
        calcE_square.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                calcE_squareActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(calcB, javax.swing.GroupLayout.PREFERRED_SIZE, 38, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(calcE_OLD)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(calcE_OLD_plus)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(calcE_square)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(calcB, javax.swing.GroupLayout.PREFERRED_SIZE, 26, Short.MAX_VALUE)
                    .addComponent(calcE_OLD, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                    .addComponent(calcE_OLD_plus, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                    .addComponent(calcE_square, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(basicInfoPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(basicSettingsPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(outputPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(observerPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, 443, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(catenaryPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(12, 12, 12)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(basicInfoPanel, javax.swing.GroupLayout.PREFERRED_SIZE, 116, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(basicSettingsPanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(outputPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, 127, Short.MAX_VALUE))
                    .addComponent(observerPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, 486, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(catenaryPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, 322, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    public boolean isBEpluspovolene() {
        return BEpluspovolene;
    }

    public void setBEpluspovolene(boolean BEpluspovolene) {
        this.BEpluspovolene = BEpluspovolene;
    }

    private void formInternalFrameClosed(javax.swing.event.InternalFrameEvent evt) {//GEN-FIRST:event_formInternalFrameClosed
        main_Jframe.window = null;

    }//GEN-LAST:event_formInternalFrameClosed

    private void calcBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_calcBActionPerformed
        try {
            //kontrolaci je vobwec nem
            //jake lano
            catenaryPanel1.calculatecatenary(); // vytvor retazovku a generuj teren ak neni
            // bnacitaj velkost elementu
            double elementh = Rozpätie.getKrok(); //help.ReadCheckIntErrorSign(basicSettingsPanel.jTextField_krok, 1000, language_internal_frame.LangLabel(constants.getLanguage_option(), 5));
            boolean sulana = true;
            if (Rozpätie.getRetazovkaList().size() == 0) {
                sulana = false;
            }

            for (int cl1 = 0; cl1 < Rozpätie.getRetazovkaList().size(); cl1++) {

                Rozpätie.getRetazovkaList().get(cl1).calcul_AllDlVectors(elementh); // priprav vsetky vektory Dl
                Rozpätie.getRetazovkaList().get(cl1).calcul_AllRoVectors(elementh); // priprav vsetky vektory R0
               
            }

            if (sulana == true) {
                //START MAIN

                // cyklus vysok Cl0
                BE.clear(); // predkaždym startom sa databaza vyčisti
                for (int cl0 = 0; cl0 < observerPanel1.Table.getSelectedRowCount(); cl0++) {

                if (observerPanel1.P1Dpriecne.isSelected() == true && observerPanel1.P1D.isSelected() == true) calculate_B_priecne(cl0); // vypočita B rpečne a napli data do databazi
                if (observerPanel1.P1Dpozdlzne.isSelected() == true && observerPanel1.P1D.isSelected() == true) calculate_B_pozdlzne(cl0);
                if (observerPanel1.P1Dpriecne.isSelected() == true && observerPanel1.P1D_free.isSelected() == true)    calculate_B_volne(cl0);
                if (observerPanel1.P2D.isSelected() == true && observerPanel1.P2Dh.isSelected() == true)    calculate_B_2D_hor(cl0);
                if (observerPanel1.P2D.isSelected() == true && observerPanel1.P2Dv.isSelected() == true)    calculate_B_2D_ver( Integer.valueOf(basicSettingsPanel.jTextField_H.getText()));

                }
                
                
                 // vystupy Graf TXT
                 if (observerPanel1.P1Dpriecne.isSelected() == true && observerPanel1.P1D.isSelected() == true){  
                 Draw_1D_graph( "priecne","Z", 0, "B", "KOKOT","PICA","POKUS");
                 }
                 
                 if (observerPanel1.P1Dpozdlzne.isSelected() == true && observerPanel1.P1D.isSelected() == true){ 
                 Draw_1D_graph("pozdlzne", "X", 1, "B", "KOKOT","PICA","POKUS");
                 }
                 if (observerPanel1.P1D.isSelected() == true && observerPanel1.P1D_free.isSelected() == true){  // ZOBRAZOVANIE TU TREBA UROBIT KOREKCIE PRE OS X STLACA GRAF DOKOPY
                 Draw_1D_graph("neurcite", "X", 2, "B", "KOKOT","PICA","POKUS");
                 }

                 if (observerPanel1.P2D.isSelected() == true && observerPanel1.P2Dh.isSelected() == true){  
                 if(outputPanel2.getConturry().isSelected()==true) Draw_2D_graph_kontury("hor",  "B", "KOKOT","PICA","POKUS");
                 if(outputPanel2.getFill().isSelected()==true) Draw_2D_graph_fill("hor",  "B", "KOKOT","PICA","POKUS");
                 }
                 
                  if (observerPanel1.P2D.isSelected() == true && observerPanel1.P2Dv.isSelected() == true){  
                 if(outputPanel2.getConturry().isSelected()==true) Draw_2D_graph_kontury("vert",  "B", "KOKOT","PICA","POKUS");
                 if(outputPanel2.getFill().isSelected()==true) Draw_2D_graph_fill("vert",  "B", "KOKOT","PICA","POKUS");
                 }
              
                
               
                
          
            }

        } catch (DelaunayError ex) {
            Logger.getLogger(InternalFrameproject.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_calcBActionPerformed
   
     /**
      * odlozene koli aalgoritmom matmatika je zla
      * @param evt 
      */
     private void calcE(java.awt.event.ActionEvent evt) {                                      
         try {
            //kontrolaci je vobwec nem
            //jake lano
            catenaryPanel1.calculatecatenary(); // vytvor retazovku a generuj teren ak neni
            // bnacitaj velkost elementu
            double elementh = Rozpätie.getKrok(); //help.ReadCheckIntErrorSign(basicSettingsPanel.jTextField_krok, 1000, language_internal_frame.LangLabel(constants.getLanguage_option(), 5));
            boolean sulana = true;
            if (Rozpätie.getRetazovkaList().size() == 0) {
                sulana = false;
            }

            for (int cl1 = 0; cl1 < Rozpätie.getRetazovkaList().size(); cl1++) {

                Rozpätie.getRetazovkaList().get(cl1).calcul_AllDlVectors(elementh); // priprav vsetky vektory Dl
                Rozpätie.getRetazovkaList().get(cl1).calcul_AllRoVectors(elementh); // priprav vsetky vektory R0
                Rozpätie.getRetazovkaList().get(cl1).calcul_AllRo_mirrorVectors_from_Ro(elementh); // priprav vsetky vektory R0_mirror
            }

            if (sulana == true) {
                //START MAIN

                // cyklus vysok Cl0
                BE.clear(); // predkaždym startom sa databaza vyčisti
                Rozpätie.calculateTau();
                for (int cl0 = 0; cl0 < observerPanel1.Table.getSelectedRowCount(); cl0++) {

                   calculate_E_priecne(cl0); // vypočita B rpečne a napli data do databazi
                   // calculate_B_pozdlzne(cl0);
                   // calculate_B_volne(cl0);
                   // calculate_B_2D_hor(cl0);
                   // calculate_B_2D_ver(40);

                }
                
               
                 
                
                plot_1D graf2 = new plot_1D(BE.getXray1D("Z", BE.getFromList1D(0, 0)), BE.getYray1DList("E", "RMS E", BE.getP1D_priecne()), "KOKOT", "PICA", "ROW1", "ROW2", BE.getYray_height_name(BE.getP1D_priecne()));
                // graf2.setunits(1000000);
                graf2.draw_1D_yn();

//                graf2 = new plot_1D(BE.getXray1D("X", BE.getFromList1D(0, 1)), BE.getYray1DList("B", "RMS B", BE.getP1D_pozdlzne()), "KOKOT", "PICA", "ROW1", "ROW2", BE.getYray_height_name(BE.getP1D_pozdlzne()));
//                graf2.setunits(1000000);
//                graf2.draw_1D_yn();
//                // ZOBRAZOVANIE TU TREBA UROBIT KOREKCIE PRE OS X STLACA GRAF DOKOPY
//                graf2 = new plot_1D(BE.getXray1D("X", BE.getFromList1D(0, 2)), BE.getYray1DList("B", "RMS B", BE.getP1D_neurcite()), "KOKOT", "PICA", "ROW1", "ROW2", BE.getYray_height_name(BE.getP1D_neurcite()));
//                graf2.setunits(1000000);
//                graf2.draw_1D_yn();
//                
//                plot_2D graf3 = new plot_2D(BE.getXray2D("X", BE.getP2D_hor()), BE.getYray2D("Z", BE.getP2D_hor()), BE.getZMAT2D("B", "RMS B", BE.getP2D_hor()),  "KOKOT", "PICA", "ROW1", "ROW2",true);
//                graf3.setunits(1000000);
//                graf3.draw_2D_yn(); 
//                
//                graf3 = new plot_2D(BE.getXray2D("Z", BE.getP2D_vert()), BE.getYray2D("Y", BE.getP2D_vert()), BE.getZMAT2D("B", "RMS B", BE.getP2D_vert()),  "KOKOT", "PICA", "ROW1", "ROW2",true);
//                graf3.setunits(1000000);
//                graf3.draw_2D_yn(); 
                // nakrm databazu nakonci observerom
                // databaza BE1D = new datazaza(); 
            }

        } catch (DelaunayError ex) {
            Logger.getLogger(InternalFrameproject.class.getName()).log(Level.SEVERE, null, ex);
        }
    }             
    
    
    private void calcE_OLDActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_calcE_OLDActionPerformed
         try {
            //kontrolaci je vobwec nem
            //jake lano
            catenaryPanel1.calculatecatenary(); // vytvor retazovku a generuj teren ak neni
            // bnacitaj velkost elementu
            double elementh = Rozpätie.getKrok(); //help.ReadCheckIntErrorSign(basicSettingsPanel.jTextField_krok, 1000, language_internal_frame.LangLabel(constants.getLanguage_option(), 5));
            boolean sulana = true;
            if (Rozpätie.getRetazovkaList().size() == 0) {
                sulana = false;
            }

            for (int cl1 = 0; cl1 < Rozpätie.getRetazovkaList().size(); cl1++) {

                Rozpätie.getRetazovkaList().get(cl1).calcul_AllDlVectors(elementh); // priprav vsetky vektory Dl
                Rozpätie.getRetazovkaList().get(cl1).calcul_AllRoVectors(elementh); // priprav vsetky vektory R0
                Rozpätie.getRetazovkaList().get(cl1).calcul_AllRo_mirrorVectors_from_Ro(elementh); // priprav vsetky vektory R0_mirror
            }

            if (sulana == true) {
                //START MAIN

                // cyklus vysok Cl0
                BE.clear(); // predkaždym startom sa databaza vyčisti
                Rozpätie.calculateTau_OLD();
                for (int cl0 = 0; cl0 < observerPanel1.Table.getSelectedRowCount(); cl0++) {

                    calculate_E_OLD_priecne(cl0); // vypočita B rpečne a napli data do databazi
                   // calculate_B_pozdlzne(cl0);
                   // calculate_B_volne(cl0);
                   // calculate_B_2D_hor(cl0);
                   // calculate_B_2D_ver(40);

                }
                
                
               
                 
                
                plot_1D graf2 = new plot_1D(BE.getXray1D("Z", BE.getFromList1D(0, 0)), BE.getYray1DList("E", "RMS E", BE.getP1D_priecne()), "KOKOT", "PICA", "ROW1", "ROW2", BE.getYray_height_name(BE.getP1D_priecne()));
                // graf2.setunits(1000000);
                graf2.draw_1D_yn();

//                graf2 = new plot_1D(BE.getXray1D("X", BE.getFromList1D(0, 1)), BE.getYray1DList("B", "RMS B", BE.getP1D_pozdlzne()), "KOKOT", "PICA", "ROW1", "ROW2", BE.getYray_height_name(BE.getP1D_pozdlzne()));
//                graf2.setunits(1000000);
//                graf2.draw_1D_yn();
//                // ZOBRAZOVANIE TU TREBA UROBIT KOREKCIE PRE OS X STLACA GRAF DOKOPY
//                graf2 = new plot_1D(BE.getXray1D("X", BE.getFromList1D(0, 2)), BE.getYray1DList("B", "RMS B", BE.getP1D_neurcite()), "KOKOT", "PICA", "ROW1", "ROW2", BE.getYray_height_name(BE.getP1D_neurcite()));
//                graf2.setunits(1000000);
//                graf2.draw_1D_yn();
//                
//                plot_2D graf3 = new plot_2D(BE.getXray2D("X", BE.getP2D_hor()), BE.getYray2D("Z", BE.getP2D_hor()), BE.getZMAT2D("B", "RMS B", BE.getP2D_hor()),  "KOKOT", "PICA", "ROW1", "ROW2",true);
//                graf3.setunits(1000000);
//                graf3.draw_2D_yn(); 
//                
//                graf3 = new plot_2D(BE.getXray2D("Z", BE.getP2D_vert()), BE.getYray2D("Y", BE.getP2D_vert()), BE.getZMAT2D("B", "RMS B", BE.getP2D_vert()),  "KOKOT", "PICA", "ROW1", "ROW2",true);
//                graf3.setunits(1000000);
//                graf3.draw_2D_yn(); 
                // nakrm databazu nakonci observerom
                // databaza BE1D = new datazaza(); 
            }

        } catch (DelaunayError ex) {
            Logger.getLogger(InternalFrameproject.class.getName()).log(Level.SEVERE, null, ex);
        }
       BEpluspovolene =true;
       calcE_OLD_plus.setEnabled(true);
    }//GEN-LAST:event_calcE_OLDActionPerformed

    private void calcE_OLD_plusActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_calcE_OLD_plusActionPerformed
     
        try {
            //kontrolaci je vobwec nem
            //jake lano
            catenaryPanel1.calculatecatenary(); // vytvor retazovku a generuj teren ak neni
            // bnacitaj velkost elementu
            double elementh = Rozpätie.getKrok(); //help.ReadCheckIntErrorSign(basicSettingsPanel.jTextField_krok, 1000, language_internal_frame.LangLabel(constants.getLanguage_option(), 5));
            boolean sulana = true;
            if (Rozpätie.getRetazovkaList().size() == 0) {
                sulana = false;
            }

            for (int cl1 = 0; cl1 < Rozpätie.getRetazovkaList().size(); cl1++) {

                Rozpätie.getRetazovkaList().get(cl1).calcul_AllDlVectors(elementh); // priprav vsetky vektory Dl
                Rozpätie.getRetazovkaList().get(cl1).calcul_AllRoVectors(elementh); // priprav vsetky vektory R0
                Rozpätie.getRetazovkaList().get(cl1).calcul_AllRo_mirrorVectors_from_Ro(elementh); // priprav vsetky vektory R0_mirror
            }

            if (sulana == true) {
                //START MAIN

                // cyklus vysok Cl0
                BEplus.clear(); // predkaždym startom sa databaza vyčisti
                Rozpätie.calculateTau_OLD();
                for (int cl0 = 0; cl0 < observerPanel1.Table.getSelectedRowCount(); cl0++) {

                    calculate_E_OLD_plus_priecne(cl0); // vypočita B rpečne a napli data do databazi
                   // calculate_B_pozdlzne(cl0);
                   // calculate_B_volne(cl0);
                   // calculate_B_2D_hor(cl0);
                   // calculate_B_2D_ver(40);

                }
                
               BE.scitanie(BEplus);
                
                plot_1D graf2 = new plot_1D(BE.getXray1D("Z", BE.getFromList1D(0, 0)), BE.getYray1DList("E", "RMS E", BE.getP1D_priecne()), "KOKOT", "PICA", "ROW1", "ROW2", BE.getYray_height_name(BE.getP1D_priecne()));
                // graf2.setunits(1000000);
                graf2.draw_1D_yn();

//                graf2 = new plot_1D(BE.getXray1D("X", BE.getFromList1D(0, 1)), BE.getYray1DList("B", "RMS B", BE.getP1D_pozdlzne()), "KOKOT", "PICA", "ROW1", "ROW2", BE.getYray_height_name(BE.getP1D_pozdlzne()));
//                graf2.setunits(1000000);
//                graf2.draw_1D_yn();
//                // ZOBRAZOVANIE TU TREBA UROBIT KOREKCIE PRE OS X STLACA GRAF DOKOPY
//                graf2 = new plot_1D(BE.getXray1D("X", BE.getFromList1D(0, 2)), BE.getYray1DList("B", "RMS B", BE.getP1D_neurcite()), "KOKOT", "PICA", "ROW1", "ROW2", BE.getYray_height_name(BE.getP1D_neurcite()));
//                graf2.setunits(1000000);
//                graf2.draw_1D_yn();
//                
//                plot_2D graf3 = new plot_2D(BE.getXray2D("X", BE.getP2D_hor()), BE.getYray2D("Z", BE.getP2D_hor()), BE.getZMAT2D("B", "RMS B", BE.getP2D_hor()),  "KOKOT", "PICA", "ROW1", "ROW2",true);
//                graf3.setunits(1000000);
//                graf3.draw_2D_yn(); 
//                
//                graf3 = new plot_2D(BE.getXray2D("Z", BE.getP2D_vert()), BE.getYray2D("Y", BE.getP2D_vert()), BE.getZMAT2D("B", "RMS B", BE.getP2D_vert()),  "KOKOT", "PICA", "ROW1", "ROW2",true);
//                graf3.setunits(1000000);
//                graf3.draw_2D_yn(); 
                // nakrm databazu nakonci observerom
                // databaza BE1D = new datazaza(); 
            }

        } catch (DelaunayError ex) {
            Logger.getLogger(InternalFrameproject.class.getName()).log(Level.SEVERE, null, ex);
        }
        
         
    }//GEN-LAST:event_calcE_OLD_plusActionPerformed

    private void calcE_squareActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_calcE_squareActionPerformed
          try {
            //kontrolaci je vobwec nem
            //jake lano
            catenaryPanel1.calculatecatenary(); // vytvor retazovku a generuj teren ak neni
            // bnacitaj velkost elementu
            double elementh = Rozpätie.getKrok(); //help.ReadCheckIntErrorSign(basicSettingsPanel.jTextField_krok, 1000, language_internal_frame.LangLabel(constants.getLanguage_option(), 5));
            boolean sulana = true;
            if (Rozpätie.getRetazovkaList().size() == 0) {
                sulana = false;
            }

            for (int cl1 = 0; cl1 < Rozpätie.getRetazovkaList().size(); cl1++) {

                Rozpätie.getRetazovkaList().get(cl1).calcul_AllDlVectors(elementh); // priprav vsetky vektory Dl
                Rozpätie.getRetazovkaList().get(cl1).calcul_AllRoVectors(elementh); // priprav vsetky vektory R0
                Rozpätie.getRetazovkaList().get(cl1).calcul_AllRo_mirrorVectors_from_Ro(elementh); // priprav vsetky vektory R0_mirror
            }

            if (sulana == true) {
                //START MAIN

                // cyklus vysok Cl0
                BE.clear(); // predkaždym startom sa databaza vyčisti
                for (int cl0 = 0; cl0 < observerPanel1.Table.getSelectedRowCount(); cl0++) {

                    calculate_E_sphere_priecne(cl0); // vypočita B rpečne a napli data do databazi
                   // calculate_B_pozdlzne(cl0);
                   // calculate_B_volne(cl0);
                   // calculate_B_2D_hor(cl0);
                   // calculate_B_2D_ver(40);

                }
                
                
               
                 
                
                plot_1D graf2 = new plot_1D(BE.getXray1D("Z", BE.getFromList1D(0, 0)), BE.getYray1DList("E", "RMS E", BE.getP1D_priecne()), "KOKOT", "PICA", "ROW1", "ROW2", BE.getYray_height_name(BE.getP1D_priecne()));
                // graf2.setunits(1000000);
                graf2.draw_1D_yn();

//                graf2 = new plot_1D(BE.getXray1D("X", BE.getFromList1D(0, 1)), BE.getYray1DList("B", "RMS B", BE.getP1D_pozdlzne()), "KOKOT", "PICA", "ROW1", "ROW2", BE.getYray_height_name(BE.getP1D_pozdlzne()));
//                graf2.setunits(1000000);
//                graf2.draw_1D_yn();
//                // ZOBRAZOVANIE TU TREBA UROBIT KOREKCIE PRE OS X STLACA GRAF DOKOPY
//                graf2 = new plot_1D(BE.getXray1D("X", BE.getFromList1D(0, 2)), BE.getYray1DList("B", "RMS B", BE.getP1D_neurcite()), "KOKOT", "PICA", "ROW1", "ROW2", BE.getYray_height_name(BE.getP1D_neurcite()));
//                graf2.setunits(1000000);
//                graf2.draw_1D_yn();
//                
//                plot_2D graf3 = new plot_2D(BE.getXray2D("X", BE.getP2D_hor()), BE.getYray2D("Z", BE.getP2D_hor()), BE.getZMAT2D("B", "RMS B", BE.getP2D_hor()),  "KOKOT", "PICA", "ROW1", "ROW2",true);
//                graf3.setunits(1000000);
//                graf3.draw_2D_yn(); 
//                
//                graf3 = new plot_2D(BE.getXray2D("Z", BE.getP2D_vert()), BE.getYray2D("Y", BE.getP2D_vert()), BE.getZMAT2D("B", "RMS B", BE.getP2D_vert()),  "KOKOT", "PICA", "ROW1", "ROW2",true);
//                graf3.setunits(1000000);
//                graf3.draw_2D_yn(); 
                // nakrm databazu nakonci observerom
                // databaza BE1D = new datazaza(); 
            }

        } catch (DelaunayError ex) {
            Logger.getLogger(InternalFrameproject.class.getName()).log(Level.SEVERE, null, ex);
        }
       BEpluspovolene =true;
       calcE_OLD_plus.setEnabled(true);
    }//GEN-LAST:event_calcE_squareActionPerformed
    


//.......................................
    //kalkulacky pozorovatelov
    //.......................................
    /**
     * funkcia ktory vytvory arraylist vektorov pozorovatela pre 1D mapovanie
     *
     * @param X1 start point X
     * @param X2 end point X
     * @param Z1 Z coordinate
     * @param Z2 Z3 coordinate
     * @param Y konstantna vyska
     * @param krok_pozorovatela ktork pozorovatela
     * @return vrati arralist
     * @throws DelaunayError
     */
    private ArrayList<DPoint> pozorovatel_1D(double X1, double X2, double Z1, double Z2, double Y, double krok_pozorovatela) throws DelaunayError {
        ArrayList<DPoint> Rp_vectors = new ArrayList<>();

        int pocet_P = (int) (Math.sqrt(Math.pow(X2 - X1, 2) + Math.pow(Z2 - Z1, 2)) / krok_pozorovatela); // pocer vektorov Rp  v realite ešte jeden navyše lebo sa zaokruhluje dole
        double alpha = 0; // uhol otocenia

        if (X1 == X2) {

            if (Z1 - Z2 < 0) {
                alpha = Math.PI / 2;
            }

            if (Z1 - Z2 > 0) {
                alpha = -Math.PI / 2;
            }

        } // n ochrana pred 90 stupnami a delenim nulou
        else {
            alpha = Math.atan((Z1 - Z2) / (X1 - X2)); // uhol otocenia // else{ alpha = Math.atan2((LCX2 - LCX1),(LCZ2 - LCZ1)   ); // else{ alpha = Math.atan((LCZ1 - LCZ2) / (LCX1 - LCX2)); // uhol otocenia

        }

        for (int cl1 = 0; cl1 <= pocet_P + 1; cl1++) {

            DPoint hodnota = new DPoint();

            if (cl1 == 0) {
                hodnota.setX(X1);
                hodnota.setY(Y);
                hodnota.setZ(Z1);
                hodnota = Rozpätie.getPole().getYaboveTer(hodnota);
            } else {

                hodnota.setX(X1 + (Math.cos(alpha) * cl1 * krok_pozorovatela));
                hodnota.setY(Y);
                hodnota.setZ(Z1 + (Math.sin(alpha) * cl1 * krok_pozorovatela));
                hodnota = Rozpätie.getPole().getYaboveTer(hodnota);
            }
            Rp_vectors.add(hodnota);
        }

        return Rp_vectors;
    }

    ;      
     /**
      * vektory RP ale len v polojhe priecnej
      * @param X1 poloha priecneho mapovania
      * @param Y vyska nad terenom
      * @param Z dlzka priecneho mapovania Z 
      * @return 
      */
    private ArrayList<DPoint> pozorovatel_1D_priecne(double X1, double Y, double krok_pozorovatela) throws DelaunayError {
        ArrayList<DPoint> Rp_vectors = new ArrayList<>();

        int pocet_P = (int) ((((Rozpätie.getZ()) * 2) / krok_pozorovatela));

        for (int cl1 = 0; cl1 <= pocet_P; cl1++) {

            DPoint hodnota = new DPoint();

            hodnota.setX(X1);
            hodnota.setY(Y);
            hodnota.setZ(-Rozpätie.getZ() + cl1 * krok_pozorovatela);  // nastavuje hodnotu Z len priecne mapovanie meni sa
            hodnota = Rozpätie.getPole().getYaboveTer(hodnota);

            Rp_vectors.add(hodnota);
        }

        return Rp_vectors;
    }

    ;   
     /**
      * vektory RP ale len v polojhe priecnej
      * @param Z1 poloha pozdlezneho
      * @param Y vyska nad terenom
      * @return 
      */
    private ArrayList<DPoint> pozorovatel_1D_pozdlezne(double Z1, double Y, double krok_pozorovatela) throws DelaunayError {
        ArrayList<DPoint> Rp_vectors = new ArrayList<>();

        int pocet_P = (int) (((Rozpätie.getA())) / krok_pozorovatela) - 1;

        for (int cl1 = 0; cl1 <= pocet_P + 1; cl1++) {

            DPoint hodnota = new DPoint();

            hodnota.setX(cl1 * krok_pozorovatela);
            hodnota.setY(Y);
            hodnota.setZ(Z1);  // nastavuje hodnotu Z len priecne mapovanie meni sa
            hodnota = Rozpätie.getPole().getYaboveTer(hodnota);

            Rp_vectors.add(hodnota);
        }

        return Rp_vectors;
    }

         
     /**
      * 
      * @param auto automatika na vzdialenost X1 alebo vlastne hodnota ak automatika tak podla prveho lana sa urči
      * @param row_index ktora vyška sa počita začina sa na 1
      * @return vektor Rp pre priečne mapovanie s poloautomatikoou
      * @throws DelaunayError 
      */
    private ArrayList<DPoint> pozorovatel_1D_priecne_final(boolean auto, int row_index) throws DelaunayError {
        ArrayList<DPoint> Rp_vectors = new ArrayList<>();
        double X1 = 0;
        double Y1 = 1.8;
        if (auto == true) {
            X1 = Rozpätie.getRetazovkaList().get(0).getA1_over();
            X1 = X1 * Math.cos(Rozpätie.getRetazovkaList().get(0).getBeta_over()); // priemet do osi X
        } else {
            X1 = observerPanel1.getPriecna_X();
        }

        Y1 = help.Object_To_double(observerPanel1.DTMTable.getValueAt(row_index, 0));

        Rp_vectors = pozorovatel_1D_priecne(X1, Y1, Rozpätie.getKrok_pozorovatela());

        return Rp_vectors;
    }

     /**
      * 
      * @param auto automatika na vzdialenost X1 alebo vlastne hodnota ak automatika tak podla prveho lana sa urči
      * @param row_index ktora vyška sa počita začina sa na 1
      * @return vektor Rp pre priečne mapovanie s poloautomatikoou
      * @throws DelaunayError 
      */
    private ArrayList<DPoint> pozorovatel_1D_priecne_final_vert(boolean auto, double height) throws DelaunayError {
        ArrayList<DPoint> Rp_vectors = new ArrayList<>();
        double X1 = 0;
       
        if (auto == true) {
            X1 = Rozpätie.getRetazovkaList().get(0).getA1_over();
            X1 = X1 * Math.cos(Rozpätie.getRetazovkaList().get(0).getBeta_over()); // priemet do osi X
        } else {
            X1 = observerPanel1.getPriecna_X();
        }

        

        Rp_vectors = pozorovatel_1D_priecne(X1, height, Rozpätie.getKrok_pozorovatela());

        return Rp_vectors;
    }

    
    
    private ArrayList<DPoint> pozorovatel_1D_volne_final(int row_index) throws DelaunayError {
        ArrayList<DPoint> Rp_vectors = new ArrayList<>();

        double Y1 = 1.8;

        double X1 = help.Object_To_double(observerPanel1.DTMTable_1D.getValueAt(0, 0));
        double Z1 = help.Object_To_double(observerPanel1.DTMTable_1D.getValueAt(0, 1));
        double X2 = help.Object_To_double(observerPanel1.DTMTable_1D.getValueAt(0, 2));
        double Z2 = help.Object_To_double(observerPanel1.DTMTable_1D.getValueAt(0, 3));

        Y1 = help.Object_To_double(observerPanel1.DTMTable.getValueAt(row_index, 0));

        Rp_vectors = pozorovatel_1D(X1, X2, Z1, Z2, Y1, Rozpätie.getKrok_pozorovatela());

        return Rp_vectors;
    }

    private ArrayList<DPoint> pozorovatel_1D_pozdlzne_final(boolean auto, int row_index) throws DelaunayError {
        ArrayList<DPoint> Rp_vectors = new ArrayList<>();
        double Z1 = 0;
        double Y1 = 1.8;
        if (auto == true) {
            Z1 = Rozpätie.getRetazovkaList().get(0).getW1_over();
            // Z1=Z1*Math.sin(Rozpätie.getRetazovkaList().get(0).getBeta_over()); // priemet do osi X
        } else {
            Z1 = observerPanel1.getPozdlzna_Z();
        }

        Y1 = help.Object_To_double(observerPanel1.DTMTable.getValueAt(row_index, 0));

        Rp_vectors = pozorovatel_1D_pozdlezne(Z1, Y1, Rozpätie.getKrok_pozorovatela());

        return Rp_vectors;
    }
    //.......................................
    //kalkulacky zakladne core jadra
    //.......................................
    /**
     *
     * @param cl0 iterator cyklu vysok
     * @throws DelaunayError
     */
    

        /**
     * nepouzivat chybna matematikka
     * @param cl0 iterator cyklu vysok
     * @throws DelaunayError
     */
    private void calculate_E_priecne(int cl0) throws DelaunayError {

        if (observerPanel1.P1Dpriecne.isSelected() == true && observerPanel1.P1D.isSelected() == true) {

            ArrayList<DPoint> Rp_vectors = new ArrayList<DPoint>();

            Rp_vectors = pozorovatel_1D_priecne_final(observerPanel1.X_precne_auto.isSelected(), observerPanel1.Table.getSelectedRow() + cl0); // cisielko nastavuje výsku a tu je itereačny člen
            //Databaza observera pre dany typ priecne mapovanie velkost ako pocet vektorov Rp
            Observer[] vektor_observerov = new Observer[Rp_vectors.size()];

            // cyklus posuvania pozorovatela
            for (int cl01 = 0; cl01 < Rp_vectors.size(); cl01++) {

                FazorVektor E = new FazorVektor(new Complex(0, 0), new Complex(0, 0), new Complex(0, 0)); // novy FV v novom bode ozorovatela
                double[][] geometrickaMaticaB = new double[3][pocet_vodicov(Rozpätie)];

                int iterator_lan = 0;

                // cyklus lan cl1
                for (int cl1 = 0; cl1 < Rozpätie.getRetazovkaList().size(); cl1++) {

                    //cyklus bundle   
                    for (int cl2 = 0; cl2 < Rozpätie.getRetazovkaList().get(cl1).getBundle_over(); cl2++) {

                        //deklaruj main B
                        E_calculation Main_E_cal_single_wire = new E_calculation(constants.getEpsi0(),
                                                                                 constants.getEpsi1(),
                                                                                 Rozpätie.getTau_real(),
                                                                                 Rozpätie.getTau_image(),
                                                                                 Rozpätie.getPolohy_lan(),
                                                                                 iterator_lan,

                                Rp_vectors.get(cl01),
                                Rozpätie.getRetazovkaList().get(cl1).getRo_vectors(),
                                Rozpätie.getRetazovkaList().get(cl1).getRo_mirror_vectors(),
                                Rozpätie.getRetazovkaList().get(cl1).getDl_vectors(),
                                Rozpätie.getRetazovkaList().get(cl1).getZY_cor_Bundle()[0][cl2],
                                Rozpätie.getRetazovkaList().get(cl1).getZY_cor_Bundle()[1][cl2],
                                Rozpätie.getRetazovkaList().get(cl1).getBeta_over());

                        // vyrataj main B
                        Main_E_cal_single_wire.run();
                        // priraduj B od kazdeho vodica
                        E.AddToFazorVektor(Main_E_cal_single_wire.getE());
                     
                        // celkovy pocet vyp vodicov
                        iterator_lan = iterator_lan + 1;
                    }

                }
                //  System.out.println( Rp_vectors.get(cl01) );
                // testovaci vypis
                //  System.out.println( constants.getMu0() ); 
                //  System.out.println("X=" + B.getX_ABS() + " <" +B.getX_Angle() );
                //  System.out.println("Y=" + B.getY_ABS() + " <" +B.getY_Angle() );
                //  System.out.println("Z=" + B.getZ_ABS() + " <" +B.getZ_Angle() );

                // Ukonceny jeden bod pozoovatela vloz hodnotu do Observera, kde sa kumuluju data E nie je pocitane
                // tu potom urobit taku ochranu že ked sa uzivatel rozhodne spocitat E ale zmeni medzitym nastavenia pre pozorovatela tak nespaja s povodnym observerom ale premaže ho
                Observer BOD = new Observer( new FazorVektor(new Complex(0, 0), new Complex(0, 0), new Complex(0, 0)),E, Rp_vectors.get(cl01), geometrickaMaticaB); //
                // testovaci vypis
//                     for (int cl4 = 0; cl4 < pocet_vodicov(Rozpätie); cl4++){
//                     System.out.println( " A= " +geometrickaMaticaB[0][cl4] + " B= " + geometrickaMaticaB[1][cl4] +" C= "+ geometrickaMaticaB[2][cl4] );
//                     }
                vektor_observerov[cl01] = BOD;

            }
            BE.addToList1D(vektor_observerov, 0);

        }

    }

    private void calculate_E_OLD_priecne(int cl0) throws DelaunayError {

        if (observerPanel1.P1Dpriecne.isSelected() == true && observerPanel1.P1D.isSelected() == true) {

            ArrayList<DPoint> Rp_vectors = new ArrayList<DPoint>();

            Rp_vectors = pozorovatel_1D_priecne_final(observerPanel1.X_precne_auto.isSelected(), observerPanel1.Table.getSelectedRow() + cl0); // cisielko nastavuje výsku a tu je itereačny člen
            //Databaza observera pre dany typ priecne mapovanie velkost ako pocet vektorov Rp
            Observer[] vektor_observerov = new Observer[Rp_vectors.size()];

            // cyklus posuvania pozorovatela
            for (int cl01 = 0; cl01 < Rp_vectors.size(); cl01++) {

                FazorVektor E = new FazorVektor(new Complex(0, 0), new Complex(0, 0), new Complex(0, 0)); // novy FV v novom bode ozorovatela
                double[][] geometrickaMaticaB = new double[3][pocet_vodicov(Rozpätie)];

                int iterator_lan = 0;

                // cyklus lan cl1
                for (int cl1 = 0; cl1 < Rozpätie.getRetazovkaList().size(); cl1++) {

                    //cyklus bundle   
                    for (int cl2 = 0; cl2 < Rozpätie.getRetazovkaList().get(cl1).getBundle_over(); cl2++) {

                        //deklaruj main B
                        E_old_calculation Main_E_cal_single_wire = new E_old_calculation(constants.getEpsi0(),
                                                                                 constants.getEpsi1(),
                                                                                 Rozpätie.getTau_real_mat(),
                                                                                 Rozpätie.getTau_image_mat(),
                                                                                 iterator_lan,

                                Rp_vectors.get(cl01),
                                Rozpätie.getRetazovkaList().get(cl1).getRo_vectors(),
                                Rozpätie.getRetazovkaList().get(cl1).getRo_mirror_vectors(),
                                Rozpätie.getRetazovkaList().get(cl1).getDl_vectors(),
                                Rozpätie.getRetazovkaList().get(cl1).getZY_cor_Bundle()[0][cl2],
                                Rozpätie.getRetazovkaList().get(cl1).getZY_cor_Bundle()[1][cl2],
                                Rozpätie.getRetazovkaList().get(cl1).getBeta_over());

                        // vyrataj main B
                        Main_E_cal_single_wire.run();
                        // priraduj B od kazdeho vodica
                        E.AddToFazorVektor(Main_E_cal_single_wire.getE());
                     
                        // celkovy pocet vyp vodicov
                        iterator_lan = iterator_lan + 1;
                    }

                }
                //  System.out.println( Rp_vectors.get(cl01) );
                // testovaci vypis
                //  System.out.println( constants.getMu0() ); 
                //  System.out.println("X=" + B.getX_ABS() + " <" +B.getX_Angle() );
                //  System.out.println("Y=" + B.getY_ABS() + " <" +B.getY_Angle() );
                //  System.out.println("Z=" + B.getZ_ABS() + " <" +B.getZ_Angle() );

                // Ukonceny jeden bod pozoovatela vloz hodnotu do Observera, kde sa kumuluju data E nie je pocitane
                // tu potom urobit taku ochranu že ked sa uzivatel rozhodne spocitat E ale zmeni medzitym nastavenia pre pozorovatela tak nespaja s povodnym observerom ale premaže ho
                Observer BOD = new Observer( new FazorVektor(new Complex(0, 0), new Complex(0, 0), new Complex(0, 0)),E, Rp_vectors.get(cl01), geometrickaMaticaB); //
                // testovaci vypis
//                     for (int cl4 = 0; cl4 < pocet_vodicov(Rozpätie); cl4++){
//                     System.out.println( " A= " +geometrickaMaticaB[0][cl4] + " B= " + geometrickaMaticaB[1][cl4] +" C= "+ geometrickaMaticaB[2][cl4] );
//                     }
                vektor_observerov[cl01] = BOD;

            }
            BE.addToList1D(vektor_observerov, 0);

        }

    }
    
    private void calculate_E_OLD_plus_priecne(int cl0) throws DelaunayError {

        if (observerPanel1.P1Dpriecne.isSelected() == true && observerPanel1.P1D.isSelected() == true) {

            ArrayList<DPoint> Rp_vectors = new ArrayList<DPoint>();

            Rp_vectors = pozorovatel_1D_priecne_final(observerPanel1.X_precne_auto.isSelected(), observerPanel1.Table.getSelectedRow() + cl0); // cisielko nastavuje výsku a tu je itereačny člen
            //Databaza observera pre dany typ priecne mapovanie velkost ako pocet vektorov Rp
            Observer[] vektor_observerov = new Observer[Rp_vectors.size()];

            // cyklus posuvania pozorovatela
            for (int cl01 = 0; cl01 < Rp_vectors.size(); cl01++) {

                FazorVektor E = new FazorVektor(new Complex(0, 0), new Complex(0, 0), new Complex(0, 0)); // novy FV v novom bode ozorovatela
                double[][] geometrickaMaticaB = new double[3][pocet_vodicov(Rozpätie)];

                int iterator_lan = 0;

                // cyklus lan cl1
                for (int cl1 = 0; cl1 < Rozpätie.getRetazovkaList().size(); cl1++) {

                    //cyklus bundle   
                    for (int cl2 = 0; cl2 < Rozpätie.getRetazovkaList().get(cl1).getBundle_over(); cl2++) {

                        //deklaruj main B
                        E_old_calculation Main_E_cal_single_wire = new E_old_calculation(constants.getEpsi0(),
                                                                                 constants.getEpsi1(),
                                                                                 Rozpätie.getTau_real_mat(),
                                                                                 Rozpätie.getTau_image_mat(),
                                                                                 iterator_lan,

                                Rp_vectors.get(cl01),
                                Rozpätie.getRetazovkaList().get(cl1).getRo_vectors(),
                                Rozpätie.getRetazovkaList().get(cl1).getRo_mirror_vectors(),
                                Rozpätie.getRetazovkaList().get(cl1).getDl_vectors(),
                                Rozpätie.getRetazovkaList().get(cl1).getZY_cor_Bundle()[0][cl2],
                                Rozpätie.getRetazovkaList().get(cl1).getZY_cor_Bundle()[1][cl2],
                                Rozpätie.getRetazovkaList().get(cl1).getBeta_over());

                        // vyrataj main B
                        Main_E_cal_single_wire.run();
                        // priraduj B od kazdeho vodica
                        E.AddToFazorVektor(Main_E_cal_single_wire.getE());
                     
                        // celkovy pocet vyp vodicov
                        iterator_lan = iterator_lan + 1;
                    }

                }
                //  System.out.println( Rp_vectors.get(cl01) );
                // testovaci vypis
                //  System.out.println( constants.getMu0() ); 
                //  System.out.println("X=" + B.getX_ABS() + " <" +B.getX_Angle() );
                //  System.out.println("Y=" + B.getY_ABS() + " <" +B.getY_Angle() );
                //  System.out.println("Z=" + B.getZ_ABS() + " <" +B.getZ_Angle() );

                // Ukonceny jeden bod pozoovatela vloz hodnotu do Observera, kde sa kumuluju data E nie je pocitane
                // tu potom urobit taku ochranu že ked sa uzivatel rozhodne spocitat E ale zmeni medzitym nastavenia pre pozorovatela tak nespaja s povodnym observerom ale premaže ho
                Observer BOD = new Observer( new FazorVektor(new Complex(0, 0), new Complex(0, 0), new Complex(0, 0)),E, Rp_vectors.get(cl01), geometrickaMaticaB); //
                // testovaci vypis
//                     for (int cl4 = 0; cl4 < pocet_vodicov(Rozpätie); cl4++){
//                     System.out.println( " A= " +geometrickaMaticaB[0][cl4] + " B= " + geometrickaMaticaB[1][cl4] +" C= "+ geometrickaMaticaB[2][cl4] );
//                     }
                vektor_observerov[cl01] = BOD;

            }
            BEplus.addToList1D(vektor_observerov, 0);

        }

    }
    
     private void calculate_E_sphere_priecne(int cl0) throws DelaunayError {

        if (observerPanel1.P1Dpriecne.isSelected() == true && observerPanel1.P1D.isSelected() == true) {

            ArrayList<DPoint> Rp_vectors = new ArrayList<DPoint>();

            Rp_vectors = pozorovatel_1D_priecne_final(observerPanel1.X_precne_auto.isSelected(), observerPanel1.Table.getSelectedRow() + cl0); // cisielko nastavuje výsku a tu je itereačny člen
            //Databaza observera pre dany typ priecne mapovanie velkost ako pocet vektorov Rp
            Observer[] vektor_observerov = new Observer[Rp_vectors.size()];

            // cyklus posuvania pozorovatela
            
            E_Spheres_calculation Main_E_cal = new E_Spheres_calculation(constants.getEpsi0(), // deklarouj
                            constants.getEpsi1(),
                            Rozpätie,
                            Rp_vectors.get(0));
            Main_E_cal.priprava(1); //priprav naboje
            
            for (int cl01 = 0; cl01 < Rp_vectors.size(); cl01++) {

                FazorVektor E = new FazorVektor(new Complex(0, 0), new Complex(0, 0), new Complex(0, 0)); // novy FV v novom bode ozorovatela
                double[][] geometrickaMaticaB = new double[3][pocet_vodicov(Rozpätie)];

                  
                    Main_E_cal.setRp(Rp_vectors.get(cl01)); // pocitaj pre dany Rp
                    Main_E_cal.run();
                    E.AddToFazorVektor(Main_E_cal.getE());   
                        
                    
                        
                     
                    
                
                  System.out.println( Rp_vectors.get(cl01) );
                // testovaci vypis
                //  System.out.println( constants.getMu0() ); 
                //  System.out.println("X=" + B.getX_ABS() + " <" +B.getX_Angle() );
                //  System.out.println("Y=" + B.getY_ABS() + " <" +B.getY_Angle() );
                //  System.out.println("Z=" + B.getZ_ABS() + " <" +B.getZ_Angle() );

                // Ukonceny jeden bod pozoovatela vloz hodnotu do Observera, kde sa kumuluju data E nie je pocitane
                // tu potom urobit taku ochranu že ked sa uzivatel rozhodne spocitat E ale zmeni medzitym nastavenia pre pozorovatela tak nespaja s povodnym observerom ale premaže ho
                Observer BOD = new Observer( new FazorVektor(new Complex(0, 0), new Complex(0, 0), new Complex(0, 0)),E, Rp_vectors.get(cl01), geometrickaMaticaB); //
                // testovaci vypis
//                     for (int cl4 = 0; cl4 < pocet_vodicov(Rozpätie); cl4++){
//                     System.out.println( " A= " +geometrickaMaticaB[0][cl4] + " B= " + geometrickaMaticaB[1][cl4] +" C= "+ geometrickaMaticaB[2][cl4] );
//                     }
                vektor_observerov[cl01] = BOD;

            }
            BE.addToList1D(vektor_observerov, 0);

        }

    }
     
    private void calculate_B_priecne(int cl0) throws DelaunayError {

        if (observerPanel1.P1Dpriecne.isSelected() == true && observerPanel1.P1D.isSelected() == true) {

            ArrayList<DPoint> Rp_vectors = new ArrayList<DPoint>();

            Rp_vectors = pozorovatel_1D_priecne_final(observerPanel1.X_precne_auto.isSelected(), observerPanel1.Table.getSelectedRow() + cl0); // cisielko nastavuje výsku a tu je itereačny člen
            //Databaza observera pre dany typ priecne mapovanie velkost ako pocet vektorov Rp
            Observer[] vektor_observerov = new Observer[Rp_vectors.size()];

            // cyklus posuvania pozorovatela
            for (int cl01 = 0; cl01 < Rp_vectors.size(); cl01++) {

                FazorVektor B = new FazorVektor(new Complex(0, 0), new Complex(0, 0), new Complex(0, 0)); // novy FV v novom bode ozorovatela
                double[][] geometrickaMaticaB = new double[3][pocet_vodicov(Rozpätie)];

                int iterator_lan = 0;

                // cyklus lan cl1
                for (int cl1 = 0; cl1 < Rozpätie.getRetazovkaList().size(); cl1++) {

                    //cyklus bundle   
                    for (int cl2 = 0; cl2 < Rozpätie.getRetazovkaList().get(cl1).getBundle_over(); cl2++) {

                        //deklaruj main B
                        B_calculation Main_B_cal_single_wire = new B_calculation(constants.getMu0(),
                                constants.getMu1(),
                                Rozpätie.getRetazovkaList().get(cl1).getI_over(),
                                Rozpätie.getRetazovkaList().get(cl1).getPhi_over(),
                                Rp_vectors.get(cl01),
                                Rozpätie.getRetazovkaList().get(cl1).getRo_vectors(),
                                Rozpätie.getRetazovkaList().get(cl1).getDl_vectors(),
                                Rozpätie.getRetazovkaList().get(cl1).getZY_cor_Bundle()[0][cl2],
                                Rozpätie.getRetazovkaList().get(cl1).getZY_cor_Bundle()[1][cl2],
                                Rozpätie.getRetazovkaList().get(cl1).getBeta_over());

                        // vyrataj main B
                        Main_B_cal_single_wire.run();
                        // priraduj B od kazdeho vodica
                        B.AddToFazorVektor(Main_B_cal_single_wire.getB());
                        // priraduj gaometricke konstanty od kazeho lana
                        geometrickaMaticaB[0][iterator_lan] = Main_B_cal_single_wire.getGeoVektor()[0];
                        geometrickaMaticaB[1][iterator_lan] = Main_B_cal_single_wire.getGeoVektor()[1];
                        geometrickaMaticaB[2][iterator_lan] = Main_B_cal_single_wire.getGeoVektor()[2];
                        // celkovy pocet vyp vodicov
                        iterator_lan = iterator_lan + 1;
                    }

                }
                //  System.out.println( Rp_vectors.get(cl01) );
                // testovaci vypis
                //  System.out.println( constants.getMu0() ); 
                //  System.out.println("X=" + B.getX_ABS() + " <" +B.getX_Angle() );
                //  System.out.println("Y=" + B.getY_ABS() + " <" +B.getY_Angle() );
                //  System.out.println("Z=" + B.getZ_ABS() + " <" +B.getZ_Angle() );

                // Ukonceny jeden bod pozoovatela vloz hodnotu do Observera, kde sa kumuluju data E nie je pocitane
                // tu potom urobit taku ochranu že ked sa uzivatel rozhodne spocitat E ale zmeni medzitym nastavenia pre pozorovatela tak nespaja s povodnym observerom ale premaže ho
                Observer BOD = new Observer(B, new FazorVektor(new Complex(0, 0), new Complex(0, 0), new Complex(0, 0)), Rp_vectors.get(cl01), geometrickaMaticaB); //
                // testovaci vypis
//                     for (int cl4 = 0; cl4 < pocet_vodicov(Rozpätie); cl4++){
//                     System.out.println( " A= " +geometrickaMaticaB[0][cl4] + " B= " + geometrickaMaticaB[1][cl4] +" C= "+ geometrickaMaticaB[2][cl4] );
//                     }
                vektor_observerov[cl01] = BOD;

            }
            BE.addToList1D(vektor_observerov, 0);

        }

    }
    
    private void calculate_B_pozdlzne(int cl0) throws DelaunayError {

        if (observerPanel1.P1Dpozdlzne.isSelected() == true && observerPanel1.P1D.isSelected() == true) {

            ArrayList<DPoint> Rp_vectors = new ArrayList<DPoint>();

            Rp_vectors = pozorovatel_1D_pozdlzne_final(observerPanel1.Z_pozdl_auto.isSelected(), observerPanel1.Table.getSelectedRow() + cl0); // cisielko nastavuje výsku a tu je itereačny člen
            //Databaza observera pre dany typ priecne mapovanie velkost ako pocet vektorov Rp
            Observer[] vektor_observerov = new Observer[Rp_vectors.size()];

            // cyklus posuvania pozorovatela
            for (int cl01 = 0; cl01 < Rp_vectors.size(); cl01++) {
                Complex NULA = new Complex(0, 0);
                FazorVektor B = new FazorVektor(NULA, NULA, NULA); // novy FV v novom bode ozorovatela
                double[][] geometrickaMaticaB = new double[3][pocet_vodicov(Rozpätie)];
                int iterator_lan = 0;

                // cyklus lan cl1
                for (int cl1 = 0; cl1 < Rozpätie.getRetazovkaList().size(); cl1++) {

                    //cyklus bundle   
                    for (int cl2 = 0; cl2 < Rozpätie.getRetazovkaList().get(cl1).getBundle_over(); cl2++) {

                        //deklaruj main B
                        B_calculation Main_B_cal_single_wire = new B_calculation(constants.getMu0(),
                                constants.getMu1(),
                                Rozpätie.getRetazovkaList().get(cl1).getI_over(),
                                Rozpätie.getRetazovkaList().get(cl1).getPhi_over(),
                                Rp_vectors.get(cl01),
                                Rozpätie.getRetazovkaList().get(cl1).getRo_vectors(),
                                Rozpätie.getRetazovkaList().get(cl1).getDl_vectors(),
                                Rozpätie.getRetazovkaList().get(cl1).getZY_cor_Bundle()[0][cl2],
                                Rozpätie.getRetazovkaList().get(cl1).getZY_cor_Bundle()[1][cl2],
                                Rozpätie.getRetazovkaList().get(cl1).getBeta_over());

                        // vyrataj main B
                        Main_B_cal_single_wire.run();
                        // priraduj B od kazdeho vodica
                        B.AddToFazorVektor(Main_B_cal_single_wire.getB());
                        // priraduj gaometricke konstanty od kazeho lana
                        geometrickaMaticaB[0][iterator_lan] = Main_B_cal_single_wire.getGeoVektor()[0];
                        geometrickaMaticaB[1][iterator_lan] = Main_B_cal_single_wire.getGeoVektor()[1];
                        geometrickaMaticaB[2][iterator_lan] = Main_B_cal_single_wire.getGeoVektor()[2];
                        // celkovy pocet vyp vodicov
                        iterator_lan = iterator_lan + 1;
                    }

                }
                //  System.out.println( Rp_vectors.get(cl01) );
                // testovaci vypis
                //  System.out.println( constants.getMu0() ); 
                //  System.out.println("X=" + B.getX_ABS() + " <" +B.getX_Angle() );
                //  System.out.println("Y=" + B.getY_ABS() + " <" +B.getY_Angle() );
                //  System.out.println("Z=" + B.getZ_ABS() + " <" +B.getZ_Angle() );

                // Ukonceny jeden bod pozoovatela vloz hodnotu do Observera, kde sa kumuluju data E nie je pocitane
                // tu potom urobit taku ochranu že ked sa uzivatel rozhodne spocitat E ale zmeni medzitym nastavenia pre pozorovatela tak nespaja s povodnym observerom ale premaže ho
                Observer BOD = new Observer(B, new FazorVektor(NULA, NULA, NULA), Rp_vectors.get(cl01), geometrickaMaticaB); //
                // testovaci vypis
//                     for (int cl4 = 0; cl4 < pocet_vodicov(Rozpätie); cl4++){
//                     System.out.println( " A= " +geometrickaMaticaB[0][cl4] + " B= " + geometrickaMaticaB[1][cl4] +" C= "+ geometrickaMaticaB[2][cl4] );
//                     }
                vektor_observerov[cl01] = BOD;

            }
            // vloznie do databazy
            BE.addToList1D(vektor_observerov, 1);

        }

    }

    private void calculate_B_volne(int cl0) throws DelaunayError {

        if (observerPanel1.P1Dpriecne.isSelected() == true && observerPanel1.P1D_free.isSelected() == true) {

            ArrayList<DPoint> Rp_vectors = new ArrayList<DPoint>();

            Rp_vectors = pozorovatel_1D_volne_final(observerPanel1.Table.getSelectedRow() + cl0); // cisielko nastavuje výsku a tu je itereačny člen
            //Databaza observera pre dany typ priecne mapovanie velkost ako pocet vektorov Rp
            Observer[] vektor_observerov = new Observer[Rp_vectors.size()];

            // cyklus posuvania pozorovatela
            for (int cl01 = 0; cl01 < Rp_vectors.size(); cl01++) {

                FazorVektor B = new FazorVektor(new Complex(0, 0), new Complex(0, 0), new Complex(0, 0)); // novy FV v novom bode ozorovatela
                double[][] geometrickaMaticaB = new double[3][pocet_vodicov(Rozpätie)];

                int iterator_lan = 0;

                // cyklus lan cl1
                for (int cl1 = 0; cl1 < Rozpätie.getRetazovkaList().size(); cl1++) {

                    //cyklus bundle   
                    for (int cl2 = 0; cl2 < Rozpätie.getRetazovkaList().get(cl1).getBundle_over(); cl2++) {

                        //deklaruj main B
                        B_calculation Main_B_cal_single_wire = new B_calculation(constants.getMu0(),
                                constants.getMu1(),
                                Rozpätie.getRetazovkaList().get(cl1).getI_over(),
                                Rozpätie.getRetazovkaList().get(cl1).getPhi_over(),
                                Rp_vectors.get(cl01),
                                Rozpätie.getRetazovkaList().get(cl1).getRo_vectors(),
                                Rozpätie.getRetazovkaList().get(cl1).getDl_vectors(),
                                Rozpätie.getRetazovkaList().get(cl1).getZY_cor_Bundle()[0][cl2],
                                Rozpätie.getRetazovkaList().get(cl1).getZY_cor_Bundle()[1][cl2],
                                Rozpätie.getRetazovkaList().get(cl1).getBeta_over());

                        // vyrataj main B
                        Main_B_cal_single_wire.run();
                        // priraduj B od kazdeho vodica
                        B.AddToFazorVektor(Main_B_cal_single_wire.getB());
                        // priraduj gaometricke konstanty od kazeho lana
                        geometrickaMaticaB[0][iterator_lan] = Main_B_cal_single_wire.getGeoVektor()[0];
                        geometrickaMaticaB[1][iterator_lan] = Main_B_cal_single_wire.getGeoVektor()[1];
                        geometrickaMaticaB[2][iterator_lan] = Main_B_cal_single_wire.getGeoVektor()[2];
                        // celkovy pocet vyp vodicov
                        iterator_lan = iterator_lan + 1;
                    }

                }
                //  System.out.println( Rp_vectors.get(cl01) );
                // testovaci vypis
                //  System.out.println( constants.getMu0() ); 
                //  System.out.println("X=" + B.getX_ABS() + " <" +B.getX_Angle() );
                //  System.out.println("Y=" + B.getY_ABS() + " <" +B.getY_Angle() );
                //  System.out.println("Z=" + B.getZ_ABS() + " <" +B.getZ_Angle() );

                // Ukonceny jeden bod pozoovatela vloz hodnotu do Observera, kde sa kumuluju data E nie je pocitane
                // tu potom urobit taku ochranu že ked sa uzivatel rozhodne spocitat E ale zmeni medzitym nastavenia pre pozorovatela tak nespaja s povodnym observerom ale premaže ho
                Observer BOD = new Observer(B, new FazorVektor(new Complex(0, 0), new Complex(0, 0), new Complex(0, 0)), Rp_vectors.get(cl01), geometrickaMaticaB); //
                // testovaci vypis
//                     for (int cl4 = 0; cl4 < pocet_vodicov(Rozpätie); cl4++){
//                     System.out.println( " A= " +geometrickaMaticaB[0][cl4] + " B= " + geometrickaMaticaB[1][cl4] +" C= "+ geometrickaMaticaB[2][cl4] );
//                     }
                vektor_observerov[cl01] = BOD;

            }
            BE.addToList1D(vektor_observerov, 2);

        }

    }

    private void calculate_B_2D_hor(int cl0) throws DelaunayError {

        if (observerPanel1.P2D.isSelected() == true && observerPanel1.P2Dh.isSelected() == true) {

            ArrayList<DPoint> Rp_vectors = new ArrayList<DPoint>();
            int pocet_P = (int) ((((Rozpätie.getZ()) * 2) / Rozpätie.getKrok_pozorovatela()));
        for (int cl1p = 0; cl1p <= pocet_P; cl1p++) {
            //vytvaranie RP vectorov  pozdlzne 
            Rp_vectors = pozorovatel_1D_pozdlezne(-Rozpätie.getZ()+Rozpätie.getKrok_pozorovatela()*cl1p, help.Object_To_double( observerPanel1.DTMTable.getValueAt(observerPanel1.Table.getSelectedRow() + cl0, 0))  , Rozpätie.getKrok_pozorovatela()) ; // cisielko nastavuje výsku a tu je itereačny člen
            
            //Databaza observera pre dany typ priecne mapovanie velkost ako pocet vektorov Rp
            Observer[] vektor_observerov = new Observer[Rp_vectors.size()];

            // cyklus posuvania pozorovatela
            for (int cl01 = 0; cl01 < Rp_vectors.size(); cl01++) {
                Complex NULA = new Complex(0, 0);
                FazorVektor B = new FazorVektor(NULA, NULA, NULA); // novy FV v novom bode ozorovatela
                double[][] geometrickaMaticaB = new double[3][pocet_vodicov(Rozpätie)];
                int iterator_lan = 0;

                // cyklus lan cl1
                for (int cl1 = 0; cl1 < Rozpätie.getRetazovkaList().size(); cl1++) {

                    //cyklus bundle   
                    for (int cl2 = 0; cl2 < Rozpätie.getRetazovkaList().get(cl1).getBundle_over(); cl2++) {

                        //deklaruj main B
                        B_calculation Main_B_cal_single_wire = new B_calculation(constants.getMu0(),
                                constants.getMu1(),
                                Rozpätie.getRetazovkaList().get(cl1).getI_over(),
                                Rozpätie.getRetazovkaList().get(cl1).getPhi_over(),
                                Rp_vectors.get(cl01),
                                Rozpätie.getRetazovkaList().get(cl1).getRo_vectors(),
                                Rozpätie.getRetazovkaList().get(cl1).getDl_vectors(),
                                Rozpätie.getRetazovkaList().get(cl1).getZY_cor_Bundle()[0][cl2],
                                Rozpätie.getRetazovkaList().get(cl1).getZY_cor_Bundle()[1][cl2],
                                Rozpätie.getRetazovkaList().get(cl1).getBeta_over());

                        // vyrataj main B
                        Main_B_cal_single_wire.run();
                        // priraduj B od kazdeho vodica
                        B.AddToFazorVektor(Main_B_cal_single_wire.getB());
                        // priraduj gaometricke konstanty od kazeho lana
                        geometrickaMaticaB[0][iterator_lan] = Main_B_cal_single_wire.getGeoVektor()[0];
                        geometrickaMaticaB[1][iterator_lan] = Main_B_cal_single_wire.getGeoVektor()[1];
                        geometrickaMaticaB[2][iterator_lan] = Main_B_cal_single_wire.getGeoVektor()[2];
                        // celkovy pocet vyp vodicov
                        iterator_lan = iterator_lan + 1;
                    }

                }
                //  System.out.println( Rp_vectors.get(cl01) );
                // testovaci vypis
                //  System.out.println( constants.getMu0() ); 
                //  System.out.println("X=" + B.getX_ABS() + " <" +B.getX_Angle() );
                //  System.out.println("Y=" + B.getY_ABS() + " <" +B.getY_Angle() );
                //  System.out.println("Z=" + B.getZ_ABS() + " <" +B.getZ_Angle() );

                // Ukonceny jeden bod pozoovatela vloz hodnotu do Observera, kde sa kumuluju data E nie je pocitane
                // tu potom urobit taku ochranu že ked sa uzivatel rozhodne spocitat E ale zmeni medzitym nastavenia pre pozorovatela tak nespaja s povodnym observerom ale premaže ho
                Observer BOD = new Observer(B, new FazorVektor(NULA, NULA, NULA), Rp_vectors.get(cl01), geometrickaMaticaB); //
                // testovaci vypis
//                     for (int cl4 = 0; cl4 < pocet_vodicov(Rozpätie); cl4++){
//                     System.out.println( " A= " +geometrickaMaticaB[0][cl4] + " B= " + geometrickaMaticaB[1][cl4] +" C= "+ geometrickaMaticaB[2][cl4] );
//                     }
                vektor_observerov[cl01] = BOD;
        
            }
            // vloznie do databazy
            BE.addToList2D(vektor_observerov, 0); // nula je horizontal
        }
        }

    }

    private void calculate_B_2D_ver(int height) throws DelaunayError {

        if (observerPanel1.P2D.isSelected() == true && observerPanel1.P2Dv.isSelected() == true) {

            ArrayList<DPoint> Rp_vectors = new ArrayList<DPoint>();
            int pocet_P = (int) ((( height ) / Rozpätie.getKrok_pozorovatela()));
        for (int cl1p = 0; cl1p <= pocet_P; cl1p++) {
            //vytvaranie RP vectorov  pozdlzne 
            Rp_vectors = pozorovatel_1D_priecne_final_vert(observerPanel1.X_precne_auto.isSelected(),cl1p * Rozpätie.getKrok_pozorovatela() ) ;
            
            //Databaza observera pre dany typ priecne mapovanie velkost ako pocet vektorov Rp
            Observer[] vektor_observerov = new Observer[Rp_vectors.size()];

            // cyklus posuvania pozorovatela
            for (int cl01 = 0; cl01 < Rp_vectors.size(); cl01++) {
                Complex NULA = new Complex(0, 0);
                FazorVektor B = new FazorVektor(NULA, NULA, NULA); // novy FV v novom bode ozorovatela
                double[][] geometrickaMaticaB = new double[3][pocet_vodicov(Rozpätie)];
                int iterator_lan = 0;

                // cyklus lan cl1
                for (int cl1 = 0; cl1 < Rozpätie.getRetazovkaList().size(); cl1++) {

                    //cyklus bundle   
                    for (int cl2 = 0; cl2 < Rozpätie.getRetazovkaList().get(cl1).getBundle_over(); cl2++) {

                        //deklaruj main B
                        B_calculation Main_B_cal_single_wire = new B_calculation(constants.getMu0(),
                                constants.getMu1(),
                                Rozpätie.getRetazovkaList().get(cl1).getI_over(),
                                Rozpätie.getRetazovkaList().get(cl1).getPhi_over(),
                                Rp_vectors.get(cl01),
                                Rozpätie.getRetazovkaList().get(cl1).getRo_vectors(),
                                Rozpätie.getRetazovkaList().get(cl1).getDl_vectors(),
                                Rozpätie.getRetazovkaList().get(cl1).getZY_cor_Bundle()[0][cl2],
                                Rozpätie.getRetazovkaList().get(cl1).getZY_cor_Bundle()[1][cl2],
                                Rozpätie.getRetazovkaList().get(cl1).getBeta_over());

                        // vyrataj main B
                        Main_B_cal_single_wire.run();
                        // priraduj B od kazdeho vodica
                        B.AddToFazorVektor(Main_B_cal_single_wire.getB());
                        // priraduj gaometricke konstanty od kazeho lana
                        geometrickaMaticaB[0][iterator_lan] = Main_B_cal_single_wire.getGeoVektor()[0];
                        geometrickaMaticaB[1][iterator_lan] = Main_B_cal_single_wire.getGeoVektor()[1];
                        geometrickaMaticaB[2][iterator_lan] = Main_B_cal_single_wire.getGeoVektor()[2];
                        // celkovy pocet vyp vodicov
                        iterator_lan = iterator_lan + 1;
                    }

                }
                //  System.out.println( Rp_vectors.get(cl01) );
                // testovaci vypis
                //  System.out.println( constants.getMu0() ); 
                //  System.out.println("X=" + B.getX_ABS() + " <" +B.getX_Angle() );
                //  System.out.println("Y=" + B.getY_ABS() + " <" +B.getY_Angle() );
                //  System.out.println("Z=" + B.getZ_ABS() + " <" +B.getZ_Angle() );

                // Ukonceny jeden bod pozoovatela vloz hodnotu do Observera, kde sa kumuluju data E nie je pocitane
                // tu potom urobit taku ochranu že ked sa uzivatel rozhodne spocitat E ale zmeni medzitym nastavenia pre pozorovatela tak nespaja s povodnym observerom ale premaže ho
                Observer BOD = new Observer(B, new FazorVektor(NULA, NULA, NULA), Rp_vectors.get(cl01), geometrickaMaticaB); //
                // testovaci vypis
//                     for (int cl4 = 0; cl4 < pocet_vodicov(Rozpätie); cl4++){
//                     System.out.println( " A= " +geometrickaMaticaB[0][cl4] + " B= " + geometrickaMaticaB[1][cl4] +" C= "+ geometrickaMaticaB[2][cl4] );
//                     }
                vektor_observerov[cl01] = BOD;
        
            }
            // vloznie do databazy
            BE.addToList2D(vektor_observerov, 1); // nula je horizontal
        }
        }

    }
     
    private int pocet_vodicov(rozpatie X) {
        int pocel_lan = 0;

        for (int cl1 = 0; cl1 < X.getRetazovkaList().size(); cl1++) {

            //cyklus bundle   
            for (int cl2 = 0; cl2 < X.getRetazovkaList().get(cl1).getBundle_over(); cl2++) {

                pocel_lan = pocel_lan + 1;
            }

        }

        return pocel_lan;
    }
  
    
    
    private void Draw_1D_graph(String typ,String Xos,int poloha_v_dat,String BorE,String ROW1,String ROW2,String Sufix){
     String label = "kokotik";
     if(BorE=="B") label = constants.getDislin_Label_B();
     if(BorE=="E") label = constants.getDislin_Label_E();
     if(BorE=="Emod") label = constants.getDislin_Label_Emod();
      if(BorE=="I") label = constants.getDislin_Label_I();
     
    if(typ == "priecne"){
      
     plot_1D graf2 = new plot_1D(BE.getXray1D(Xos, BE.getFromList1D(0, poloha_v_dat)), BE.getYray1DList(BorE, outputPanel2.YAxisVal(BorE), BE.getP1D_priecne()), constants.getDislin_Label_Z(), label, ROW1, ROW2, BE.getYray_height_name(BE.getP1D_priecne()));         
     graf2.setunits(outputPanel2.BscaleFactor());
     graf2.setScreen(outputPanel2.getGraph_screen().isSelected());
     Date todaysDate = new Date();
      DateFormat df2 = new SimpleDateFormat("dd-MM-yyyy_HH-mm-ss");
     graf2.setFile(outputPanel2.getGraph_file().isSelected(),outputPanel2.getjTextField1().getText()+"/"+ df2.format(todaysDate) +"_"+ meno_projektu +"_"+ Sufix+ ".png" );
     graf2.draw_1D_yn();
    }
    
    if(typ == "pozdlzne"){
      
     plot_1D graf2 = new plot_1D(BE.getXray1D(Xos, BE.getFromList1D(0, poloha_v_dat)), BE.getYray1DList(BorE, outputPanel2.YAxisVal(BorE), BE.getP1D_pozdlzne()), constants.getDislin_Label_Z(), label, ROW1, ROW2, BE.getYray_height_name(BE.getP1D_pozdlzne()));         
     graf2.setunits(outputPanel2.BscaleFactor());
     graf2.setScreen(outputPanel2.getGraph_screen().isSelected());
     Date todaysDate = new Date();
      DateFormat df2 = new SimpleDateFormat("dd-MM-yyyy_HH-mm-ss");
     graf2.setFile(outputPanel2.getGraph_file().isSelected(),outputPanel2.getjTextField1().getText()+"/"+ df2.format(todaysDate) +"_"+ meno_projektu +"_"+ Sufix+ ".png" );
     graf2.draw_1D_yn();
    }
    
    if(typ == "neurcite"){
      
     plot_1D graf2 = new plot_1D(BE.getXray1D(Xos, BE.getFromList1D(0, poloha_v_dat)), BE.getYray1DList(BorE, outputPanel2.YAxisVal(BorE), BE.getP1D_neurcite()), constants.getDislin_Label_Z(), label, ROW1, ROW2, BE.getYray_height_name(BE.getP1D_neurcite()));         
     graf2.setunits(outputPanel2.BscaleFactor());
     graf2.setScreen(outputPanel2.getGraph_screen().isSelected());
     Date todaysDate = new Date();
      DateFormat df2 = new SimpleDateFormat("dd-MM-yyyy_HH-mm-ss");
     graf2.setFile(outputPanel2.getGraph_file().isSelected(),outputPanel2.getjTextField1().getText()+"/"+ df2.format(todaysDate) +"_"+ meno_projektu +"_"+ Sufix+ ".png" );
     graf2.draw_1D_yn();
    }  
      
         
    }
    
     private void Draw_2D_graph_kontury(String HORvert,String BorE,String ROW1,String ROW2,String Sufix){
     
         if(HORvert=="hor"){ 
         plot_2D graf3 = new plot_2D(BE.getXray2D("X", BE.getP2D_hor()), BE.getYray2D("Z", BE.getP2D_hor()), BE.getZMAT2D(BorE, outputPanel2.YAxisVal(BorE), BE.getP2D_hor()),  constants.getDislin_Label_X(), constants.getDislin_Label_Z(), ROW1, ROW2,true);
                graf3.setunits(outputPanel2.BscaleFactor());
                graf3.setScreen(outputPanel2.getGraph_screen().isSelected());
                Date todaysDate = new Date();
        DateFormat df2 = new SimpleDateFormat("dd-MM-yyyy_HH-mm-ss");
        graf3.setFile(outputPanel2.getGraph_file().isSelected(),outputPanel2.getjTextField1().getText()+"/"+ df2.format(todaysDate) +"_"+ meno_projektu +"_"+ Sufix+ ".png" );
     
               graf3.draw_2D_yn();
         }
         if(HORvert=="vert"){ 
         plot_2D graf3 = new plot_2D(BE.getXray2D("Z", BE.getP2D_vert()), BE.getYray2D("Y", BE.getP2D_vert()), BE.getZMAT2D(BorE, outputPanel2.YAxisVal(BorE), BE.getP2D_vert()),  constants.getDislin_Label_X(), constants.getDislin_Label_Y(), ROW1, ROW2,true);
                graf3.setunits(outputPanel2.BscaleFactor());
                graf3.setScreen(outputPanel2.getGraph_screen().isSelected());
                Date todaysDate = new Date();
        DateFormat df2 = new SimpleDateFormat("dd-MM-yyyy_HH-mm-ss");
        graf3.setFile(outputPanel2.getGraph_file().isSelected(),outputPanel2.getjTextField1().getText()+"/"+ df2.format(todaysDate) +"_"+ meno_projektu +"_"+ Sufix+ ".png" );
     
               graf3.draw_2D_yn();
         }
         
         
    }
    
     private void Draw_2D_graph_fill(String HORvert,String BorE,String ROW1,String ROW2,String Sufix){
     String label = "kokotik";
         if(BorE=="B") label = constants.getDislin_Label_B();
     if(BorE=="E") label = constants.getDislin_Label_E();
     if(BorE=="Emod") label = constants.getDislin_Label_Emod();
      if(BorE=="I") label = constants.getDislin_Label_I();
         
         
         if(HORvert=="hor"){ 
         plot_2D graf3 = new plot_2D(BE.getXray2D("X", BE.getP2D_hor()), BE.getYray2D("Z", BE.getP2D_hor()), BE.getZMAT2D(BorE, outputPanel2.YAxisVal(BorE), BE.getP2D_hor()),  constants.getDislin_Label_X(), constants.getDislin_Label_Z(), ROW1, ROW2,true,label);
                graf3.setunits(outputPanel2.BscaleFactor());
                graf3.setScreen(outputPanel2.getGraph_screen().isSelected());
                Date todaysDate = new Date();
        DateFormat df2 = new SimpleDateFormat("dd-MM-yyyy_HH-mm-ss");
        graf3.setFile(outputPanel2.getGraph_file().isSelected(),outputPanel2.getjTextField1().getText()+"/"+ df2.format(todaysDate) +"_"+ meno_projektu +"_"+ Sufix+ ".png" );
     
               graf3.draw_2D_yn();
         }
         if(HORvert=="vert"){ 
         plot_2D graf3 = new plot_2D(BE.getXray2D("Z", BE.getP2D_vert()), BE.getYray2D("Y", BE.getP2D_vert()), BE.getZMAT2D(BorE, outputPanel2.YAxisVal(BorE), BE.getP2D_vert()),  constants.getDislin_Label_X(), constants.getDislin_Label_Y(), ROW1, ROW2,true,label);
                graf3.setunits(outputPanel2.BscaleFactor());
                graf3.setScreen(outputPanel2.getGraph_screen().isSelected());
                Date todaysDate = new Date();
        DateFormat df2 = new SimpleDateFormat("dd-MM-yyyy_HH-mm-ss");
        graf3.setFile(outputPanel2.getGraph_file().isSelected(),outputPanel2.getjTextField1().getText()+"/"+ df2.format(todaysDate) +"_"+ meno_projektu +"_"+ Sufix+ ".png" );
     
               graf3.draw_2D_yn();
         }
         
         
    }
    
     
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private InternalFrame.BasicInfoPanel basicInfoPanel;
    private InternalFrame.BasicSettingsPanel basicSettingsPanel;
    private javax.swing.JButton calcB;
    private javax.swing.JButton calcE_OLD;
    public static javax.swing.JButton calcE_OLD_plus;
    private javax.swing.JButton calcE_square;
    private InternalFrame.CatenaryPanel catenaryPanel1;
    private javax.swing.JMenuItem jMenuItem1;
    private javax.swing.JPanel jPanel1;
    private InternalFrame.ObserverPanel observerPanel1;
    private InternalFrame.outputPanel outputPanel2;
    // End of variables declaration//GEN-END:variables
    //public static Boolean IsOpen = false;

}

class language_internal_frame {

    /**
     * Function just add elements to the array list If once function runs and
     * sets variable "inicializovane" true it never runs again
     */
    static void constructor() {
        /*SK*/ /*CZ*/ /*EN*/
 /*0*/ SK.add("Nové rozpätie");
        CZ.add("MT3 software, SAG Elektrovod, autoři Jozef Bendík & Matej Cenký 2016 1.release");
        EN.add("MT3 software, SAG Elektrovod, created by Jozef Bendík & Matej Cenký 2016 1.release");
        /*1*/ SK.add("Nový projekt");
        CZ.add("MT3 software, SAG Elektrovod, autoři Jozef Bendík & Matej Cenký 2016 1.release");
        EN.add("MT3 software, SAG Elektrovod, created by Jozef Bendík & Matej Cenký 2016 1.release");  //language String value  at position 
        /*2*/ SK.add("Os - X ");
        CZ.add("MT3 software, SAG Elektrovod, autoři Jozef Bendík & Matej Cenký 2016 1.release");
        EN.add("MT3 software, SAG Elektrovod, created by Jozef Bendík & Matej Cenký 2016 1.release");  //language String value  at position             //language String value  at position 
        /*3*/ SK.add("Os - Y ");
        CZ.add("MT3 software, SAG Elektrovod, autoři Jozef Bendík & Matej Cenký 2016 1.release");
        EN.add("MT3 software, SAG Elektrovod, created by Jozef Bendík & Matej Cenký 2016 1.release");  //language String value  at position                      
        /*4*/ SK.add("Os - Z ");
        CZ.add("MT3 software, SAG Elektrovod, autoři Jozef Bendík & Matej Cenký 2016 1.release");
        EN.add("MT3 software, SAG Elektrovod, created by Jozef Bendík & Matej Cenký 2016 1.release");  //language String value  at position                         
        /*5*/ SK.add("Zla hodnota deltaL, korektura na 1000 mm");
        CZ.add("MT3 software, SAG Elektrovod, autoři Jozef Bendík & Matej Cenký 2016 1.release");
        EN.add("MT3 software, SAG Elektrovod, created by Jozef Bendík & Matej Cenký 2016 1.release");  //language String value  at position                             

        // language_main_frame.LangLabel(constants.getLanguage_option(),0)      
        inicializovane = true;
    }

    /**
     * Function returns on string label in set language
     *
     * @param X defines the language 1 Slovak, 2 Czech, 3 English
     * @param Y defines the label position according the drawing, is starts from
     * 0
     * @return
     */
    public static String LangLabel(int X, int Y) {

        if (inicializovane == false) {
            constructor();
        }

        String SlovoDaloSlovo = "empty";
        switch (X) {
            case 1:
                SlovoDaloSlovo = SK.get(Y);
                break;
            case 2:
                SlovoDaloSlovo = CZ.get(Y);
                break;
            case 3:
                SlovoDaloSlovo = EN.get(Y);
                break;
        }
        return SlovoDaloSlovo;
    }

    public static String LangLabel2() {

        String SlovoDaloSlovo = "empty";

        return SlovoDaloSlovo;
    }
    private static final ArrayList<String> SK = new ArrayList<>();
    private static final ArrayList<String> CZ = new ArrayList<>();
    private static final ArrayList<String> EN = new ArrayList<>();
    private static boolean inicializovane = false;
}
